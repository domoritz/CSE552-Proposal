% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[11pt]{article}

\usepackage{geometry}
\usepackage{amsmath,amsthm,amssymb,url}
\usepackage{fullpage}
\usepackage{tabularx}
\usepackage{float}

\usepackage{graphicx}
\usepackage{xcolor}
\definecolor{darkblue}{rgb}{0,0,0.5} 
\usepackage{transparent}

%\addtolength{\topmargin}{-.5in}
%\addtolength{\textheight}{1.2in}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{question}[2][Question]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\title{Project outline \--- Distributed Systems}
\author{Shumo Chu and Dominik Moritz}
\date{}

\maketitle

\section{Background}

Database system need to transform user's high level queries, eg. SQL, Datalog into physical query plan for the execution. Physical query plan is the actual execution map of a database system. Usually it can be viewed as a \emph{DAG} which consists of basic operators, such as \emph{JOIN}, \emph{GROUP BY}, \emph{SCAN}, \emph{APPLY} and relational tables. In distributed database systems, the introduction of the \emph{SHUFFLE} operator and data partitioning makes query plans more complicated. All operators are distributed over a number of nodes.

Myria is a distributed big data management system currently being developed in the database group. Myria aims towards building a distributed database platform to provide \emph{big data management and analytics as a service} for scientific and many other applications.

\section{Objective}

We propose a project that will help us to understand the execution of physical query plans in the Myria database. It will allow us to efficiently debug and improve query execution.

We will develop a system that will allow us to collect information about the execution of a physical query plan in the distributed system. The data has to be collected on one node and then aggregated to provide the foundation for analyzing the data and creating a meaningful visualization. We also plan to analyze the query execution and find problems such as data skew. The visualization will be embedded in a web application. We plan to use a gantt chart to visualize events happening in operators over time. The visualization will also show the relationships between operators and their location.

\vspace{10px}

\noindent Questions that we want to answer in this project:

\begin{enumerate}
	\item What are the data dependencies between operators in workers?
	\item What is the bottleneck of the execution? Improving which part could best boost the performance?
		%\item How does an optimization rule affect query execution?
	%\item Is an execution network or CPU bound?
	\item How does network and computation contribute to the total running time? We make two hypothesis, respectively. If we assume the network has infinite bandwidth and no latency, how would the running time change. If we assume that we have infinite computation power, how would the running time change.
	\item Is there a slow worker during a certain stage of the execution that prevent the progress of the whole query plan?
	%\item How good is the load balancing? If it is skewed, how much does this affect the performance?

\end{enumerate}

Visualizing the physical execution will allows us to understand, debug and eventually improve how queries are executed.

\section{Methodoloy}
\subsection{Problem formulation}
\label{sec:formulation}

Database system profiling has been extensively studied over decades. There are two types of works on this topic. One is logging query execution information and analyzing logs afterwards for better query optimization. The other is using real-time profiling information to estimate the progress of a query. We focus on the first type of problem in the context of distributed database system.

\begin{figure}
 \begin{center}
     \includegraphics[width=0.7\textwidth]{myria.png}
   \end{center}
  \caption{distributed database architecture}
  \label{fig:myria_arc}
\end{figure}

\textbf{Distributed database system} is a database system deployed on a cluster of servers.  Figure \ref{fig:myria_arc} shows the system architecture of the distributed database system we use. There is a master server who parses the query and distribute the tasks the each computing node (worker). The data is also pre-partitioned and stored in each work.  The database query in the form of SQL or Datalog will be translated to the physical query plan and then be executed. Each query plan is consisted by basic operators forming a execution flow. An example of visualized query plan is showed in Figure \ref{fig:query_plan}. 

\begin{figure}
 \begin{center}
     \includegraphics[width=0.4\textwidth]{partition_join.png}
   \end{center}
  \caption{query plan: distributed hash join}
  \label{fig:query_plan}
\end{figure}


% explain what we want to learn about operators, query fragments and workers
% talk about shared memory model

\subsection{Proposed implementation}
	\subsubsection*{Logging}
	% signal/state
	% what do we collect
	% how do we collect
	% how do we send the data to visualization server
	% how does the visualization server process the data
	
	As described in Section~\ref{sec:formulation}, we want to capture the state of operators, query fragments, and workers. The state of a query fragment depends on the state of the operators inside it and the state of a worker depends on the state of the query fragments that are running on it. Consequently, we only need to capture the state of query fragments per worker. In order to capture state changes, we log events and state changes of operators. In the logs we look for events that indicate a state change and signals that caused a state change. We use the term \emph{state} to describe the state of an operator and the term \emph{signal} to describe events that caused a state change.

	Not all operators have the same states. A consumer for example does not have a wait, compute or send state. Table~\ref{tbl:state} shows the different states operators can be in and briefly describes their meaning.

\begin{table}[H]
\begin{tabularx}{\textwidth}{ l|X|X|X }
 & \multicolumn{3}{ c }{operator type} \\
\cline{2-4}
state & producers & consumers & operations \newline (\emph{JOIN}, \emph{MERGE}, \emph{SCAN}, \emph{APPLY}, ...) \\
\hline \hline
receive & - & receiving data from producer over network & - \\
\hline
wait & child is producing & - & waiting for child to return \\
\hline
compute & hashing data & - & in \texttt{fetchNextReady} and not waiting for any data \\
\hline
sleep & has data for consumer that is not ready & no data in producer & waiting for signal \\
\hline
send & sending data to consumer over network & - & - \\
\end{tabularx}
\caption{Possible states of operators and their meaning.}
\label{tbl:state}
\end{table}

In order to capture these states we have to log events that indicate their beginning and their end. An operator can only be in one state at a time. Consequently, the states can be reconstructed from the logs without any information about which events belong to each other. Since we also log the time of the events we can reconstruct when an operator changes its state and determine how long it has been in a certain state.

No all transitions between states are possible. For example, the wait state can only be reached from the compute state. A way to interpret this is that wait and compute are a sub-states of another state work. This is shown in Figure~\ref{fig:extd_compute}. This interpretation is useful since a set of computes and waits can be grouped together because they were triggered by a call to \texttt{fetchNextReady} and end with a return from the function. We will use this information in the visualization of operator states.

\begin{figure}
  \begin{center}
    \def\svgwidth{0.4\columnwidth}
    \input{wait_states.pdf_tex}
  \end{center}
  \caption{Extended automaton for alternative interpretation where the wait state and the compute state are sub states of a work state.}
  \label{fig:extd_compute}
\end{figure}

% compute and wait, overlapping
% state changes

	\subsubsection*{Visualization}
	% Web client
	% Form of visualization, e.g. what do we visualize, operator, query fragment, workers. In each kind of visualization, how will the interface looks like.
	% What kind of information a potential user can get from the visualization.
	
	%\subsubsection*{Analytics}
	\subsubsection*{Estimate computation/network overhead}

%\section{Result}
%\section{Summary}


\end{document}